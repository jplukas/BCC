<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notas de aula de Laboratório de Métodos numéricos</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  
  
  
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Notas de aula de Laboratório de Métodos numéricos</h1>
<p class="author"><div class="line-block">João Pedro Lukasavicus Silva<br />
jplukasavicus@gmail.com</div></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#ponto-flutuante-ieee" id="toc-ponto-flutuante-ieee"><span class="toc-section-number">0.1</span> Ponto Flutuante IEEE</a></li>
<li><a href="#inteiros" id="toc-inteiros"><span class="toc-section-number">0.2</span> Inteiros</a>
<ul>
<li><a href="#complemento-de-2" id="toc-complemento-de-2"><span class="toc-section-number">0.2.1</span> Complemento de 2</a></li>
</ul></li>
<li><a href="#nao-inteiros" id="toc-nao-inteiros"><span class="toc-section-number">0.3</span> Nao inteiros</a>
<ul>
<li><a href="#ponto-fixo" id="toc-ponto-fixo"><span class="toc-section-number">0.3.1</span> Ponto fixo</a></li>
<li><a href="#ponto-flutuante" id="toc-ponto-flutuante"><span class="toc-section-number">0.3.2</span> Ponto Flutuante</a></li>
<li><a href="#precisao-epsilon-de-maquina-e-ulp" id="toc-precisao-epsilon-de-maquina-e-ulp"><span class="toc-section-number">0.3.3</span> Precisao, epsilon de maquina e ulp</a></li>
<li><a href="#o-numero-especial-zero" id="toc-o-numero-especial-zero"><span class="toc-section-number">0.3.4</span> O Numero especial Zero</a></li>
<li><a href="#diferenças-de-densidade" id="toc-diferenças-de-densidade"><span class="toc-section-number">0.3.5</span> Diferenças de densidade</a></li>
</ul></li>
<li><a href="#a-representação-de-ponto-flutuante-do-ieee" id="toc-a-representação-de-ponto-flutuante-do-ieee"><span class="toc-section-number">1</span> A representação de ponto flutuante do IEEE</a>
<ul>
<li><a href="#ponto-flutuante-do-ieee-requisitos" id="toc-ponto-flutuante-do-ieee-requisitos"><span class="toc-section-number">1.1</span> Ponto flutuante do IEEE, requisitos</a></li>
<li><a href="#o-formato-single" id="toc-o-formato-single"><span class="toc-section-number">1.2</span> O formato Single</a></li>
<li><a href="#subnormais" id="toc-subnormais"><span class="toc-section-number">1.3</span> Subnormais</a></li>
<li><a href="#o-formato-double" id="toc-o-formato-double"><span class="toc-section-number">1.4</span> O formato Double</a></li>
<li><a href="#single-vs-double" id="toc-single-vs-double"><span class="toc-section-number">1.5</span> Single vs Double</a></li>
<li><a href="#o-formato-extended" id="toc-o-formato-extended"><span class="toc-section-number">1.6</span> O formato Extended</a></li>
<li><a href="#precisão-e-epsilon-de-máquina-dos-formatos-ieee" id="toc-precisão-e-epsilon-de-máquina-dos-formatos-ieee"><span class="toc-section-number">1.7</span> Precisão e epsilon de máquina dos formatos IEEE</a></li>
<li><a href="#dígitos-significativos" id="toc-dígitos-significativos"><span class="toc-section-number">1.8</span> Dígitos significativos</a></li>
<li><a href="#big-e-little-endian" id="toc-big-e-little-endian"><span class="toc-section-number">1.9</span> Big e Little Endian</a></li>
</ul></li>
<li><a href="#algoritmos-numéricos-e-erros" id="toc-algoritmos-numéricos-e-erros"><span class="toc-section-number">2</span> Algoritmos numéricos e erros</a>
<ul>
<li><a href="#erros-absolutos-e-relativos" id="toc-erros-absolutos-e-relativos"><span class="toc-section-number">2.1</span> Erros absolutos e relativos</a></li>
<li><a href="#erros-de-aproximação" id="toc-erros-de-aproximação"><span class="toc-section-number">2.2</span> Erros de aproximação</a></li>
<li><a href="#erros-de-arredondamento" id="toc-erros-de-arredondamento"><span class="toc-section-number">2.3</span> Erros de arredondamento</a></li>
<li><a href="#condicionamento-de-problemas-e-estabilidade-de-algoritmos" id="toc-condicionamento-de-problemas-e-estabilidade-de-algoritmos"><span class="toc-section-number">2.4</span> Condicionamento de problemas e estabilidade de algoritmos</a>
<ul>
<li><a href="#acumulação-de-erros" id="toc-acumulação-de-erros"><span class="toc-section-number">2.4.1</span> Acumulação de erros</a></li>
</ul></li>
<li><a href="#exercícios" id="toc-exercícios"><span class="toc-section-number">2.5</span> Exercícios</a></li>
<li><a href="#método-da-bissecção" id="toc-método-da-bissecção"><span class="toc-section-number">2.6</span> Método da bissecção</a>
<ul>
<li><a href="#convergência-do-método-da-bissecção" id="toc-convergência-do-método-da-bissecção"><span class="toc-section-number">2.6.1</span> Convergência do método da bissecção</a></li>
<li><a href="#exercícios-1" id="toc-exercícios-1"><span class="toc-section-number">2.6.2</span> Exercícios</a></li>
</ul></li>
<li><a href="#iteração-de-ponto-fixo" id="toc-iteração-de-ponto-fixo"><span class="toc-section-number">2.7</span> Iteração de ponto fixo</a>
<ul>
<li><a href="#teorema-do-ponto-fixo" id="toc-teorema-do-ponto-fixo"><span class="toc-section-number">2.7.1</span> Teorema do ponto fixo</a></li>
<li><a href="#convergência-do-método-do-ponto-fixo" id="toc-convergência-do-método-do-ponto-fixo"><span class="toc-section-number">2.7.2</span> Convergência do método do ponto fixo</a></li>
<li><a href="#taxa-de-convergência" id="toc-taxa-de-convergência"><span class="toc-section-number">2.7.3</span> Taxa de convergência</a></li>
<li><a href="#método-de-newton-e-variantes" id="toc-método-de-newton-e-variantes"><span class="toc-section-number">2.7.4</span> Método de Newton e variantes</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<p>Aula 2: (16/03/23) Epsilon da máquina, unit in the last place,
arredondamento e operações artiméticas. Capítulos 4-7 do livro [Ov].
Exercícios recomendados: todos os dos captítulos 1 a 7 do livro [Ov].</p>
<h2 data-number="0.1" id="ponto-flutuante-ieee"><span class="header-section-number">0.1</span> Ponto Flutuante IEEE</h2>
<p>No padrao IEEE de ponto flutuante, temos um bit para o # Representação
de números no computador</p>
<p>Como o computador representa, armazena e faz cálculos com números? Para
analizar isso, vamos dividir esse assunto entre números inteiros e
reais.</p>
<p>Para o computador, ao invés do sistema decimal, usamos o sistema binário
para representar números, por conveniência. Isso se deve ao fato dos
circuitos lógicos do computador trabalharem com dois estados básicos: 0
e 1, ou ligado e desligado, etc. Em um computador, a menor unidade de
informação é um bit (abreviação de binary digit), cujo valor é 0 ou 1.
Um byte é uma sequência de 8 bits. Uma word é uma sequência de 4 bytes
(ou 32 bits).</p>
<h2 data-number="0.2" id="inteiros"><span class="header-section-number">0.2</span> Inteiros</h2>
<p>Tipicamente, inteiros são representados usando uma word, ou 32 bits.
Para inteiros não-negativos, poderíamos simplesmente utilizar a notação
usual em base 2 para representar um inteiro <span class="math inline">\(x\)</span> entre <span class="math inline">\(0\)</span> e
<span class="math inline">\(2^{32} - 1\)</span>, podendo assim representar <span class="math inline">\(2^{32}\)</span> inteiros não-negativos
diferentes.<br />
Por exemplo, o número <span class="math inline">\(71\)</span> poderia ser representado como
<span class="math display">\[000000000000000000000000001000111\]</span> e o número <span class="math inline">\(0\)</span> como
<span class="math display">\[000000000000000000000000000000000\]</span></p>
<h3 data-number="0.2.1" id="complemento-de-2"><span class="header-section-number">0.2.1</span> Complemento de 2</h3>
<p>Para representar números negativos, uma ideia seria usar o bit mais
significativo (mais a esquerda) para representar o sinal, e o restante
para representar o módulo do número. Assim, o número <span class="math inline">\(-71\)</span> seria
representado como <span class="math display">\[100000000000000000000000001000111\]</span> Poderíamos dizer
que desse modo, poderíamos representar <span class="math inline">\(2^{32}\)</span> inteiros diferentes,
metade positiva e metade negativa, porém, nesse esquema, o número <span class="math inline">\(0\)</span>
seria representado de duas formas distintas:
<span class="math display">\[000000000000000000000000000000000\]</span> e
<span class="math display">\[100000000000000000000000000000000\]</span> então apenas podemos representar
números inteiros entre <span class="math inline">\(-2^{32} + 1\)</span> e <span class="math inline">\(2^{32} - 1\)</span>.</p>
<p>Outra forma de se representar inteiros, mais conveniente, é por meio do
complemento de 2. Nessa forma, um inteiro não-negativo entre <span class="math inline">\(0\)</span> e
<span class="math inline">\(2^{32} - 1\)</span> é representado de maneira usual, segundo sua expansão
binária. Porém, um inteiro negativo <span class="math inline">\(-y\)</span> é representado segundo a
expansão binária <span class="math inline">\(2^{32} - y\)</span>.<br />
Por exemplo, o número <span class="math inline">\(71\)</span> seria representado da maneira usual, enquanto
o número <span class="math inline">\(-71\)</span> seria representado como
<span class="math display">\[111111111111111111111111110111001\]</span> Para verificar que essa
representação é correta, vamos adicionar as representações de <span class="math inline">\(71\)</span> e
<span class="math inline">\(-71\)</span>: <span class="math display">\[
000000000000000000000000001000111+ \\
111111111111111111111111110111001 \\
= 1000000000000000000000000000000000\]</span> Entao, retirando-se o bit de
overflow, obtemos a representacao correta do resultado.</p>
<p>Podemos agora entao representar inteiros entre <span class="math inline">\(-2^{32}\)</span> e <span class="math inline">\(2^{32} - 1\)</span>.</p>
<h2 data-number="0.3" id="nao-inteiros"><span class="header-section-number">0.3</span> Nao inteiros</h2>
<h3 data-number="0.3.1" id="ponto-fixo"><span class="header-section-number">0.3.1</span> Ponto fixo</h3>
<p>Na representação de ponto fixo, dividimos a word em três partes. Um bit
para o sinal, 15 bits para a parte inteira e 16 bits para a parte não
inteira (depois da vírgula, na representação binária). Desse modo, temos
como representar números desde 2^-15 até 2^15. O número 11/2 seria
representado como: |0|000000000000101|100000000000000|
|-|—————|—————|</p>
<h3 data-number="0.3.2" id="ponto-flutuante"><span class="header-section-number">0.3.2</span> Ponto Flutuante</h3>
<p>No sistema de ponto flutuante, representamos um número real de forma
similar a notação científica (ou exponencial). Seja um número real <span class="math inline">\(x\)</span>,
representamos <span class="math inline">\(x\)</span> na notação científica como <span class="math inline">\(x = S \cdot 10^E\)</span>, com
<span class="math inline">\(1 \leq S &lt; 10\)</span>. Isto é, representamos o número <span class="math inline">\(233,526\)</span> em notação
científica como <span class="math inline">\(2,33526 \cdot 10^{2}\)</span>. No nosso caso, como queremos
representar números reais em um computador, usaremos o sistema binário
para isso. Então, dado um número real <span class="math inline">\(x\)</span>, o representaremos como
<span class="math inline">\(x = S \cdot 2^E\)</span>, onde <span class="math inline">\(1 \leq S &lt; 2\)</span>. Assim, dividimos a word em três
partes: um bit para o sinal, oito bits para o expoente <span class="math inline">\(E\)</span>, e 23 bits
para a mantissa <span class="math inline">\(S\)</span>. Assim, o número <span class="math inline">\(11/2\)</span> seria representado como:
|0|00000011|10110000000000000000000|
|-|——–|———————–| Porém, como <span class="math inline">\(1 \leq S\)</span>, então o
primeiro bit de <span class="math inline">\(S\)</span> deve sempre ser <span class="math inline">\(1\)</span>, e não precisamos armazenar esse
bit. De fato, não o fazemos na prática, e então nossa representação para
o número <span class="math inline">\(11/2\)</span> fica como |0|00000010|01100000000000000000000|
|-|——–|———————–|</p>
<p>Assim, podemos armazenar números de <span class="math inline">\(2^{-256}\)</span> a <span class="math inline">\(2^{256}\)</span> (embora não
todos os números entre eles), o que não é possível utilizando inteiros
de 32 bits! (Por quê? Como a máquina faz operações aritméticas de ponto
flutuante?)</p>
<h3 data-number="0.3.3" id="precisao-epsilon-de-maquina-e-ulp"><span class="header-section-number">0.3.3</span> Precisao, epsilon de maquina e ulp</h3>
<p>A precisão de um sistema de ponto flutuante é determinado pelo número de
bits da mantissa mais o bit escondido. Nós denotamos esse número por
<span class="math inline">\(p\)</span>. No caso anterior, <span class="math inline">\(p = 24\)</span>. O menor número de ponto flutuante que é
maior do que <span class="math inline">\(1\)</span> é: <span class="math display">\[
    (1.000\dots 1)_{2} = 1 + 2^{-(p-1)}
\]</span> Ao intervalo entre <span class="math inline">\(1\)</span> e esse número, damos o nome de épsilon da
máquina: <span class="math display">\[
    \epsilon = 1 + 2^{-(p-1)} - 1 = 2^{1-p}
\]</span> Mais geralmente, para qualquer número de ponto flutuante
<span class="math inline">\(x = S \cdot 2^E\)</span>, denominamos <span class="math inline">\(ulp(x) = \epsilon \cdot 2^{E}\)</span>. Ou seja,
<span class="math inline">\(ulp(x)\)</span> é o intervalo entre <span class="math inline">\(x\)</span> e o próximo número de ponto flutuante.</p>
<h3 data-number="0.3.4" id="o-numero-especial-zero"><span class="header-section-number">0.3.4</span> O Numero especial Zero</h3>
<p>Para representar o número <span class="math inline">\(0\)</span>, temos um problema, pois com o bit <span class="math inline">\(1\)</span>
escondido na mantissa, se todos os bits da nossa mantissa forem <span class="math inline">\(0\)</span>, o
número representado será somente uma potência de <span class="math inline">\(2\)</span>. Uma possibilidade
de se tratar esse problema é esquecer a ideia do bit escondido, e perder
um bit de precisão, ou utilizar uma bitstring de zeros no expoente para
sinalizar quando o número é zero. Veremos mais adiante como o sistema
IEEE resolve esse problema.</p>
<h3 data-number="0.3.5" id="diferenças-de-densidade"><span class="header-section-number">0.3.5</span> Diferenças de densidade</h3>
<p>Considere a distância entre os números de ponto flutuante com expoente
igual a <span class="math inline">\(0\)</span> (isto é, <span class="math inline">\(E = 0\)</span>). Já vimos que
<span class="math inline">\(ulp(x) = 2^E \cdot \epsilon\)</span>. Então, nesse caso, <span class="math inline">\(ulp(x) = \epsilon\)</span>
para todos esses números. Já para o caso em que <span class="math inline">\(E\)</span> é um número grande,
digamos, <span class="math inline">\(20\)</span>, temos que <span class="math inline">\(ulp(x) = 2^{20} \cdot \epsilon\)</span>. Então as
distâncias entre os números de ponto flutuante aumentam conforme
aumentam os expoentes.</p>
<h1 data-number="1" id="a-representação-de-ponto-flutuante-do-ieee"><span class="header-section-number">1</span> A representação de ponto flutuante do IEEE</h1>
<h2 data-number="1.1" id="ponto-flutuante-do-ieee-requisitos"><span class="header-section-number">1.1</span> Ponto flutuante do IEEE, requisitos</h2>
<p>Todos os formatos de representação de números de ponto flutuante do IEEE
tem 3 requisitos básicos:</p>
<ul>
<li>Representação consistente de números de ponto flutuante</li>
<li>Operações aritméticas com arredondamento correto com modos de
arredondamento diferentes</li>
<li>Tratamento consistente de situações excepcionais como divisão por
<span class="math inline">\(0\)</span>.</li>
</ul>
<h2 data-number="1.2" id="o-formato-single"><span class="header-section-number">1.2</span> O formato Single</h2>
<h2 data-number="1.3" id="subnormais"><span class="header-section-number">1.3</span> Subnormais</h2>
<h2 data-number="1.4" id="o-formato-double"><span class="header-section-number">1.4</span> O formato Double</h2>
<h2 data-number="1.5" id="single-vs-double"><span class="header-section-number">1.5</span> Single vs Double</h2>
<h2 data-number="1.6" id="o-formato-extended"><span class="header-section-number">1.6</span> O formato Extended</h2>
<h2 data-number="1.7" id="precisão-e-epsilon-de-máquina-dos-formatos-ieee"><span class="header-section-number">1.7</span> Precisão e epsilon de máquina dos formatos IEEE</h2>
<h2 data-number="1.8" id="dígitos-significativos"><span class="header-section-number">1.8</span> Dígitos significativos</h2>
<h2 data-number="1.9" id="big-e-little-endian"><span class="header-section-number">1.9</span> Big e Little Endian</h2>
<h1 data-number="2" id="algoritmos-numéricos-e-erros"><span class="header-section-number">2</span> Algoritmos numéricos e erros</h1>
<p>Todo cálculo de interesse terá algum erro. Nosso objetivo é nos
certificar que esse erro será pequeno.</p>
<h2 data-number="2.1" id="erros-absolutos-e-relativos"><span class="header-section-number">2.1</span> Erros absolutos e relativos</h2>
<p>Podemos classificar os erros em medições em dois tipos básicos: erros
absolutos e erros relativos. Seja <span class="math inline">\(u\)</span> uma quantidade escalar de
interesse, e seja <span class="math inline">\(v\)</span> uma aproximação de <span class="math inline">\(u\)</span>:</p>
<ul>
<li>O <strong><em>erro absoluto</em></strong> em <span class="math inline">\(v\)</span> é dado por <span class="math inline">\(|u-v|\)</span></li>
<li>O <strong><em>erro relativo</em></strong> (assumindo que <span class="math inline">\(u \neq 0\)</span>) em <span class="math inline">\(v\)</span> é dado por
<span class="math inline">\(\frac{|u-v|}{|u|}\)</span> O erro relativo geralmente é uma medida mais
apropriada da qualidade de uma aproximação do que o erro absoluto.</li>
</ul>
<h2 data-number="2.2" id="erros-de-aproximação"><span class="header-section-number">2.2</span> Erros de aproximação</h2>
<p>Quando utilizamos uma aproximação de uma função ao invés da função de
fato, nos deparamos com erros de aproximação. Podemos classificá-los em
dois tipos:</p>
<ul>
<li><strong>Erros de discretização</strong>: Aparecem quando truncamos, ou
discretizamos processos contínuos, como diferenciação, integração e
interpolação.</li>
<li><strong>Erros de convergência</strong>: Muitos métodos que utilizamos são métodos
iterativos, que a partir de uma aproximação inicial, refinam essa
aproximação iterativamente até chegar em uma estimativa <em>próxima</em> do
valor real, porque precisamos parar o nosso método iterativo em
algum ponto.</li>
</ul>
<h2 data-number="2.3" id="erros-de-arredondamento"><span class="header-section-number">2.3</span> Erros de arredondamento</h2>
<p>Qualquer computação com números reais está sujeita a erros de
arredondamento, devido a precisão finita da representação de números
reais no computador. Erros de discretização e convergência podem ser
mitigados por meio da análise dos métodos utilizados, porém erros de
arredondamento dependem da plataforma onde os nossos programas rodarão.
Nossa hipótese básica é que erros de aproximação dominam erros de
arredondamento em magnitude em geral.</p>
<h2 data-number="2.4" id="condicionamento-de-problemas-e-estabilidade-de-algoritmos"><span class="header-section-number">2.4</span> Condicionamento de problemas e estabilidade de algoritmos</h2>
<h3 data-number="2.4.1" id="acumulação-de-erros"><span class="header-section-number">2.4.1</span> Acumulação de erros</h3>
<h2 data-number="2.5" id="exercícios"><span class="header-section-number">2.5</span> Exercícios</h2>
<ol type="1">
<li><p>Use o método das diferenças finitas para fazer uma aproximação da
derivada da função <span class="math inline">\(f(x) = e^{-2x}\)</span> avaliada em <span class="math inline">\(x_{0} = 0.5\)</span>.
Sabemos que a função <span class="math inline">\(f(x) = e^{-2x}\)</span> tem derivada igual a
<span class="math inline">\(-2e^{-2x}\)</span>. Em <span class="math inline">\(x = 0.5\)</span> o valor dessa derivada é <span class="math inline">\(\frac{-2}{e}\)</span>.
No nosso código, avaliamos a derivada utilizando o método das
diferenças finitas, ou seja:
<span class="math inline">\(f^{\prime }(x) \approx \frac{f(x + h) - f(x)}{h}\)</span>. Avaliamos essa
expressão para diferentes valores de <span class="math inline">\(h\)</span>.</p>
<div class="sourceCode" id="cb1" data-startFrom="1"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> math</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">def</span> f(x):</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">return</span> math.exp((<span class="op">-</span><span class="dv">2</span>) <span class="op">*</span> x)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>x_0 <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>f_x <span class="op">=</span> f(x_0)</span>
<span id="cb1-9"><a href="#cb1-9"></a>actual <span class="op">=</span> <span class="op">-</span><span class="fl">2.0</span> <span class="op">*</span> f(x_0)</span>
<span id="cb1-10"><a href="#cb1-10"></a>start <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>end <span class="op">=</span> <span class="dv">18</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>x <span class="op">=</span> []</span>
<span id="cb1-13"><a href="#cb1-13"></a>y <span class="op">=</span> []</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end):</span>
<span id="cb1-15"><a href="#cb1-15"></a>    h <span class="op">=</span> <span class="fl">10.0</span> <span class="op">**</span> (<span class="op">-</span>i)</span>
<span id="cb1-16"><a href="#cb1-16"></a>    d_dx <span class="op">=</span> (f(x_0 <span class="op">+</span> h) <span class="op">-</span> f_x) <span class="op">/</span> h</span>
<span id="cb1-17"><a href="#cb1-17"></a>    abs_diff <span class="op">=</span> <span class="bu">abs</span>(d_dx <span class="op">-</span> actual)</span>
<span id="cb1-18"><a href="#cb1-18"></a>    rel_diff <span class="op">=</span> abs_diff <span class="op">/</span> <span class="bu">abs</span>(actual)</span>
<span id="cb1-19"><a href="#cb1-19"></a>    x.append(h)</span>
<span id="cb1-20"><a href="#cb1-20"></a>    y.append(rel_diff)</span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="bu">print</span>(<span class="ss">f&quot;\(10^</span><span class="ch">{{</span><span class="ss">-</span><span class="sc">{</span>i<span class="sc">:02d}</span><span class="ch">}}</span><span class="ss"> \quad </span><span class="sc">{</span>d_dx<span class="sc">:+.20f}</span><span class="ss"> \quad</span><span class="sc">{</span>abs_diff<span class="sc">:.10f}</span><span class="ss"> \quad </span><span class="sc">{</span>rel_diff<span class="sc">:.10f}</span><span class="ss">\)&quot;</span>)</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>plt.plot(x, y)</span>
<span id="cb1-24"><a href="#cb1-24"></a>plt.yscale(<span class="st">&#39;log&#39;</span>)</span>
<span id="cb1-25"><a href="#cb1-25"></a>plt.xscale(<span class="st">&#39;log&#39;</span>)</span></code></pre></div>
<p><img src="dist/79bd8a4fc0e48def/ex1-1.png" title="fig:" class="richOutput" /></p>
<p>(10^{-01} )
(10^{-02} )
(10^{-03} )
(10^{-04} )
(10^{-05} )
(10^{-06} )
(10^{-07} )
(10^{-08} )
(10^{-09} )
(10^{-10} )
(10^{-11} )
(10^{-12} )
(10^{-13} )
(10^{-14} )
(10^{-15} )
(10^{-16} )
(10^{-17} +0.00000000000000000000 )</p></li>
<li><p>Use o método das diferenças finitas para fazer uma aproximação da
derivada da função <span class="math inline">\(f(x) = \sin x\)</span> avaliada em
<span class="math inline">\(x_{0} = \frac{\pi }{2}\)</span>. Mostre que o erro desta aproximação é
<span class="math inline">\(\mathcal{O}(n²)\)</span>. Sabemos que a função <span class="math inline">\(f(x) = \sin x\)</span> tem derivada
igual a <span class="math inline">\(\cos x\)</span>. Em <span class="math inline">\(x = \frac{\pi }{2}\)</span> o valor dessa derivada é
<span class="math inline">\(0\)</span>. No nosso código, avaliamos a derivada utilizando o método das
diferenças finitas, ou seja:
<span class="math inline">\(f^{\prime }(x) \approx \frac{f(x + h) - f(x - h)}{2h}\)</span>. Avaliamos
essa expressão para diferentes valores de <span class="math inline">\(h\)</span>.</p>
<div class="sourceCode" id="cb2" data-startFrom="26"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 25;"><span id="cb2-26"><a href="#cb2-26"></a><span class="im">import</span> math</span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a>x_0 <span class="op">=</span> math.pi <span class="op">/</span> <span class="fl">3.0</span></span>
<span id="cb2-30"><a href="#cb2-30"></a>actual <span class="op">=</span> math.cos(x_0)</span>
<span id="cb2-31"><a href="#cb2-31"></a>start <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>end <span class="op">=</span> <span class="dv">18</span></span>
<span id="cb2-33"><a href="#cb2-33"></a>x <span class="op">=</span> []</span>
<span id="cb2-34"><a href="#cb2-34"></a>y <span class="op">=</span> []</span>
<span id="cb2-35"><a href="#cb2-35"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end):</span>
<span id="cb2-36"><a href="#cb2-36"></a>    h <span class="op">=</span> <span class="fl">10.0</span> <span class="op">**</span> (<span class="op">-</span>i)</span>
<span id="cb2-37"><a href="#cb2-37"></a>    d_dx <span class="op">=</span> (math.sin(x_0 <span class="op">+</span> h) <span class="op">-</span> math.sin(x_0 <span class="op">-</span> h)) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> h)</span>
<span id="cb2-38"><a href="#cb2-38"></a>    abs_diff <span class="op">=</span> <span class="bu">abs</span>(d_dx <span class="op">-</span> actual)</span>
<span id="cb2-39"><a href="#cb2-39"></a>    rel_diff <span class="op">=</span> abs_diff <span class="op">/</span> <span class="bu">abs</span>(actual)</span>
<span id="cb2-40"><a href="#cb2-40"></a>    x.append(h)</span>
<span id="cb2-41"><a href="#cb2-41"></a>    y.append(rel_diff)</span>
<span id="cb2-42"><a href="#cb2-42"></a>    <span class="bu">print</span>(<span class="ss">f&quot;\(10^</span><span class="ch">{{</span><span class="ss">-</span><span class="sc">{</span>i<span class="sc">:02d}</span><span class="ch">}}</span><span class="ss"> \quad </span><span class="sc">{</span>d_dx<span class="sc">:+.20f}</span><span class="ss"> \quad</span><span class="sc">{</span>abs_diff<span class="sc">:.10f}</span><span class="ss"> \quad </span><span class="sc">{</span>rel_diff<span class="sc">:.10f}</span><span class="ss">\)&quot;</span>)</span>
<span id="cb2-43"><a href="#cb2-43"></a></span>
<span id="cb2-44"><a href="#cb2-44"></a>plt.plot(x, y)</span>
<span id="cb2-45"><a href="#cb2-45"></a>plt.yscale(<span class="st">&#39;log&#39;</span>)</span>
<span id="cb2-46"><a href="#cb2-46"></a>plt.xscale(<span class="st">&#39;log&#39;</span>)</span></code></pre></div>
<pre class="stdout"><code>\(10^{-01} \quad +0.49916708323414105131 \quad0.0008329168 \quad 0.0016658335\)
\(10^{-02} \quad +0.49999166670833816717 \quad0.0000083333 \quad 0.0000166666\)
\(10^{-03} \quad +0.49999991666660470457 \quad0.0000000833 \quad 0.0000001667\)
\(10^{-04} \quad +0.49999999916672255296 \quad0.0000000008 \quad 0.0000000017\)
\(10^{-05} \quad +0.49999999999217331625 \quad0.0000000000 \quad 0.0000000000\)
\(10^{-06} \quad +0.49999999995886668103 \quad0.0000000000 \quad 0.0000000001\)
\(10^{-07} \quad +0.50000000029193358841 \quad0.0000000003 \quad 0.0000000006\)
\(10^{-08} \quad +0.49999999696126451454 \quad0.0000000030 \quad 0.0000000061\)
\(10^{-09} \quad +0.50000004137018549955 \quad0.0000000414 \quad 0.0000000827\)
\(10^{-10} \quad +0.50000004137018549955 \quad0.0000000414 \quad 0.0000000827\)
\(10^{-11} \quad +0.50000004137018549955 \quad0.0000000414 \quad 0.0000000827\)
\(10^{-12} \quad +0.50004445029117050581 \quad0.0000444503 \quad 0.0000889006\)
\(10^{-13} \quad +0.49960036108132044319 \quad0.0003996389 \quad 0.0007992778\)
\(10^{-14} \quad +0.49960036108132044319 \quad0.0003996389 \quad 0.0007992778\)
\(10^{-15} \quad +0.55511151231257827021 \quad0.0551115123 \quad 0.1102230246\)
\(10^{-16} \quad +0.00000000000000000000 \quad0.5000000000 \quad 1.0000000000\)
\(10^{-17} \quad +0.00000000000000000000 \quad0.5000000000 \quad 1.0000000000\)</code></pre>
<p><img src="dist/79bd8a4fc0e48def/python3--002-01.png" title="fig:" class="richOutput" /></p>
<h1 id="equações-não-lineares-em-uma-variável">Equações não-lineares em uma variável</h1></li>
</ol>
<h2 data-number="2.6" id="método-da-bissecção"><span class="header-section-number">2.6</span> Método da bissecção</h2>
<p>O método da bisecção é simples. Imagine que, dada uma função contínua
<span class="math inline">\(f(x)\)</span> temos um intervalo <span class="math inline">\([a, b] \in \mathbb{R}\)</span> tal que sabemos que
<span class="math inline">\(f\)</span> muda de sinal, isto é, <span class="math inline">\(f(a)\cdot f(b) &lt; 0\)</span>. Pelo Teorema do Valor
Intermediário, temos que deve existir <span class="math inline">\(c \in [a, b]\)</span> tal que <span class="math inline">\(f(c) = 0\)</span>.
Então avaliamos <span class="math inline">\(f(p)\)</span>, onde <span class="math inline">\(p = \frac{a+b}{2}\)</span> é a média entre <span class="math inline">\(a\)</span> e
<span class="math inline">\(b\)</span>, e checamos o valor de <span class="math inline">\(f(a) \cdot f(b)\)</span>. Se esse valor for <span class="math inline">\(0\)</span>,
então <span class="math inline">\(p\)</span> é uma raiz. Se esse valor for negativo, então fazemos
<span class="math inline">\(b \leftarrow p\)</span> e recomeçamos. Senão, fazemos <span class="math inline">\(a \leftarrow p\)</span> e
recomeçamos, até que estejamos a uma distância aceitável da raiz.</p>
<h3 data-number="2.6.1" id="convergência-do-método-da-bissecção"><span class="header-section-number">2.6.1</span> Convergência do método da bissecção</h3>
<p>A cada iteração do método, o intervalo <span class="math inline">\([a,b]\)</span> onde a raiz <span class="math inline">\(x^{*}\)</span> está
“presa” diminui pela metade. Então, após um total de <span class="math inline">\(n\)</span> iterações,
temos que <span class="math inline">\(|x^{*} - x_{n}| \leq \frac{b-a}{2}2^{-n}\)</span>. Então, o algoritmo
garantidamente converge. Para que o algoritmo satisfaça
<span class="math inline">\(|x^{*} - x_{n}| \leq \text{atol}\)</span>, para uma tolerância absoluta
<span class="math inline">\(\text{atol}\)</span>, em <span class="math inline">\(n\)</span> iterações, podemos fazer
<span class="math inline">\(\frac{b-a}{2}2^{-n} \leq \text{atol}\)</span>, e então $n =
_{2}
(
) $.</p>
<h3 data-number="2.6.2" id="exercícios-1"><span class="header-section-number">2.6.2</span> Exercícios</h3>
<ol type="1">
<li><p>Utilize o método da bisecção para encontrar a raiz da função
<span class="math inline">\(f(x) = \sqrt[]{x} - 1.1\)</span> começando do intervalo <span class="math inline">\([0,2]\)</span>, com
<span class="math inline">\(\text{atol} = 10^{-8}\)</span>.</p>
<ol type="1">
<li><p>Quantas iterações são necessárias? A quantidade real de
iterações é compatível com a nossa análise de convergência?</p>
<p>Seguindo o modelo da nossa análise, temos que: <span class="math display">\[
\begin{align*}
     n &amp;=  \left\lceil
             \log_{2}
             \dfrac{2}{2 \cdot 10 ^{-8}}
         \right\rceil \\
         n &amp;= \left\lceil
             \log_{2}
             10 ^{8}
         \right\rceil \\
         n &amp;= \left\lceil
             8 \log_{2} 10
         \right\rceil \\
         n &amp;= \lceil 26.5754247591 \rceil \\
         n &amp;= 27
\end{align*}
\]</span></p>
<div class="sourceCode" id="cb4" data-startFrom="47"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 46;"><span id="cb4-47"><a href="#cb4-47"></a><span class="im">import</span> math</span>
<span id="cb4-48"><a href="#cb4-48"></a></span>
<span id="cb4-49"><a href="#cb4-49"></a><span class="kw">def</span> f(x):</span>
<span id="cb4-50"><a href="#cb4-50"></a>    <span class="cf">return</span> math.sqrt(x) <span class="op">-</span> <span class="fl">1.1</span></span>
<span id="cb4-51"><a href="#cb4-51"></a></span>
<span id="cb4-52"><a href="#cb4-52"></a>actual <span class="op">=</span> <span class="fl">1.1</span> <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb4-53"><a href="#cb4-53"></a>a <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-54"><a href="#cb4-54"></a>b <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-55"><a href="#cb4-55"></a>atol <span class="op">=</span> <span class="dv">10</span> <span class="op">**</span> (<span class="op">-</span><span class="dv">8</span>)</span>
<span id="cb4-56"><a href="#cb4-56"></a>n <span class="op">=</span> math.ceil(math.log2((b<span class="op">-</span>a)<span class="op">/</span>(<span class="dv">2</span> <span class="op">*</span> atol)))</span>
<span id="cb4-57"><a href="#cb4-57"></a><span class="bu">print</span>(<span class="ss">f&quot;Quantidade de iterações: </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb4-58"><a href="#cb4-58"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb4-59"><a href="#cb4-59"></a>    p <span class="op">=</span> (a <span class="op">+</span> b) <span class="op">/</span> (<span class="fl">2.0</span>)</span>
<span id="cb4-60"><a href="#cb4-60"></a>    f_p <span class="op">=</span> f(p)</span>
<span id="cb4-61"><a href="#cb4-61"></a>    <span class="bu">print</span>(<span class="ss">f&quot;\(p= </span><span class="sc">{</span>p<span class="sc">:+.10f}</span><span class="ss">; \quad f(p)= </span><span class="sc">{</span>f_p<span class="sc">:+.10f}</span><span class="ss">\)&quot;</span>)</span>
<span id="cb4-62"><a href="#cb4-62"></a>    <span class="cf">if</span> f_p <span class="op">*</span> f(a) <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb4-63"><a href="#cb4-63"></a>        b <span class="op">=</span> p</span>
<span id="cb4-64"><a href="#cb4-64"></a>    <span class="cf">else</span>:</span>
<span id="cb4-65"><a href="#cb4-65"></a>        a <span class="op">=</span> p</span>
<span id="cb4-66"><a href="#cb4-66"></a></span>
<span id="cb4-67"><a href="#cb4-67"></a>abs_error <span class="op">=</span> <span class="bu">abs</span>(actual <span class="op">-</span> p)</span>
<span id="cb4-68"><a href="#cb4-68"></a><span class="bu">print</span>(<span class="ss">f&quot;\(p= </span><span class="sc">{</span>p<span class="sc">:+.10f}</span><span class="ss">\)&quot;</span>)</span>
<span id="cb4-69"><a href="#cb4-69"></a><span class="bu">print</span>(<span class="ss">f&quot;\(</span><span class="ch">\\</span><span class="ss">text</span><span class="ch">{{</span><span class="ss">abs error</span><span class="ch">}}</span><span class="ss">= </span><span class="sc">{</span>abs_error<span class="sc">:.2E}</span><span class="ss">\)&quot;</span>)</span></code></pre></div></li>
<li><p>Qual é o erro absoluto? Esse erro poderia ser predito pela nossa
análise de convergência?</p>
<p>A nossa análise de convergência nos garante que, após <span class="math inline">\(27\)</span>
iterações, o erro absoluto deve ser menor do que <span class="math inline">\(10^{-8}\)</span>, e de
fato, o erro absoluto obtido foi de
<span class="math inline">\(|1.2099999934 - 10^{-8}| \approx 6.56E−09\)</span>.</p></li>
</ol></li>
</ol>
<h2 data-number="2.7" id="iteração-de-ponto-fixo"><span class="header-section-number">2.7</span> Iteração de ponto fixo</h2>
<p>Considere nosso problema de encontrar <span class="math inline">\(x\)</span> tal que <span class="math inline">\(f(x) = 0\)</span>. Podemos
reescrever esse problema como encontrar <span class="math inline">\(x\)</span> tal que
<span class="math inline">\(g(x) = x \iff f(x) = 0\)</span>. Isto significa que passamos então a procurar
um ponto fixo <span class="math inline">\(x^{*}\)</span> tal que <span class="math inline">\(g(x^{*}) = x^{*}\)</span>. No método do ponto
fixo, definimos uma sequência de iterandos
<span class="math inline">\(x_{1}, x_{2}, \dots, x_{k}, \dots\)</span> por <span class="math inline">\(x_{k+1} = x_{k}\)</span>, começando por
um iterando inicial <span class="math inline">\(x_{0}\)</span>.</p>
<h3 data-number="2.7.1" id="teorema-do-ponto-fixo"><span class="header-section-number">2.7.1</span> Teorema do ponto fixo</h3>
<h3 data-number="2.7.2" id="convergência-do-método-do-ponto-fixo"><span class="header-section-number">2.7.2</span> Convergência do método do ponto fixo</h3>
<h3 data-number="2.7.3" id="taxa-de-convergência"><span class="header-section-number">2.7.3</span> Taxa de convergência</h3>
<h3 data-number="2.7.4" id="método-de-newton-e-variantes"><span class="header-section-number">2.7.4</span> Método de Newton e variantes</h3>
<h4 data-number="2.7.4.1" id="método-de-newton"><span class="header-section-number">2.7.4.1</span> Método de Newton</h4>
<p>No método de Newton</p>
<h5 data-number="2.7.4.1.1" id="exercícios-2"><span class="header-section-number">2.7.4.1.1</span> Exercícios</h5>
<ol type="1">
<li><p>Considere a iteração de ponto fixo <span class="math inline">\(x_{k+1} = g(x_{k})\)</span>, e deixe que
todas as hipóteses do teorema do ponto fixo sejam verdadeiras. Use
uma expansão da série de Taylor para mostrar que a ordem de
convergência do método depende da quantidade de derivadas que
desaparecem em <span class="math inline">\(x = x^{*}\)</span>. Use esse resultado para mostrar o quão
rápido esse método deve convergir para
<span class="math inline">\(g^{\prime }(x^{*}) = \dots = g^{(r)}(x^{*}) = 0\)</span>, onde o inteiro
<span class="math inline">\(r \geq 1\)</span> é dado.</p>
<p>Se as hipóteses do Teorema do Ponto Fixo são válidas, então temos
que <span class="math inline">\(g \in C^{r}[a,b]\)</span>, e <span class="math inline">\(a \leq g(x) \leq b\)</span>, e além disso, existe
<span class="math inline">\(\rho &lt; 1\)</span> tal que <span class="math inline">\(|g^{\prime }(x)| \leq \rho\)</span> Temos que, segundo a
expansão da série de taylor para a função <span class="math inline">\(g(x)\)</span> que: <span class="math display">\[
g(x_k) = \sum_{n=0}^{r} \dfrac{g^{(n)}(x)}{n!} (x_k - x)^{n} + \dfrac{g^{(r + 1)}(\xi_{k})}{(r + 1)!} (x_k - x)^{r + 1}\\
g(x_k) = \dfrac{g^{(r + 1)}(\xi )}{(r + 1)!} (x_k - x^{*})^{r + 1}\\
\]</span> Vamos definir <span class="math inline">\(\epsilon*{k}\)</span> como o erro <span class="math inline">\(x*{k} - x^{*}\)</span>. Como
<span class="math inline">\(g(x_{k}) = x_{k+1}\)</span>, temos <span class="math display">\[
\epsilon*{k + 1} = \dfrac{g^{(r + 1)}(\xi*{k})}{(r + 1)!} \epsilon*{k}^{r + 1} - x^{*}
\]</span> Vamos definir <span class="math inline">\(C = \dfrac{g^{(r + 1)}(\xi*{k})}{(r + 1)!}\)</span>
então, temos que: <span class="math display">\[
\dfrac{|\epsilon_{k+1}|}{|\epsilon*{k}|} =
\dfrac{C|\epsilon*{k}^{r+1} - x^{*}|}{|\epsilon_{k}|} \approx C|\epsilon_{k}|^r
\]</span></p></li>
<li><p>Considere a função <span class="math inline">\(g(x) = x^{2} + \frac{3}{16}\)</span>.</p>
<ol type="1">
<li><p>Essa função tem dois pontos fixos. Quais são?</p>
<p>Os pontos fixos dessa função são os pontos <span class="math inline">\(x^{*}\)</span> tais que
<span class="math inline">\(g(x^{*}) = x^{*}\)</span>, ou seja, <span class="math inline">\({x^*}^{2} + \frac{3}{16} = x^{*}\)</span>,
isto é, as raízes da equação
<span class="math inline">\({x^{*}}^{2} - x^{*} + \frac{3}{16} = 0\)</span>, que são os valores
<span class="math inline">\(\{\frac{1}{4}, \frac{3}{4}\}\)</span>.</p>
<ol start="2" type="1">
<li>Considere a iteração de ponto fixo <span class="math inline">\(x_{k+1} = g(x_{k})\)</span>.
Para quais dos pontos fixos podemos ter certeza que a nossa
iteração irá convergir? Segundo o teorema do ponto fixo,
somente podemos ter certeza da convergência da iteração para
um ponto fixo em uma vizinhança do ponto onde a primeira
derivada da função for menor (em valor absoluto) do que <span class="math inline">\(1\)</span>,
isto é: <span class="math display">\[
|g^{\prime }(x)| &lt; 1
\]</span> No nosso caso, então: <span class="math display">\[
|2x| &lt; 1 \iff -\frac{1}{2} &lt; x &lt; \frac{1}{2}
\]</span> Assim, como dos pontos fixos que encontramos em (1),
apenas <span class="math inline">\(\frac{1}{4}\)</span> atende esse requisito, a função somente
irá convergir para esse ponto (claro, quando
<span class="math inline">\(-\frac{1}{2} &lt; x &lt; \frac{1}{2}\)</span>).</li>
</ol></li>
<li><p>Para o ponto ou pontos encontrados em (2), quantas iterações
serão necessárias para reduzir o erro de convergência por um
fator de 10?</p>
<p>Temos que, segundo o teorema do valor intermediário, que
<span class="math inline">\(|x_{k} - \frac{1}{4}| \approx \rho^{k} |x_{0} - \frac{1}{4}|\)</span>,
onde
<span class="math inline">\(\rho = |g^{\prime }(\frac{1}{4})| = |2 \cdot \frac{1}{4}| = \frac{1}{2}\)</span>.
Então temos que <span class="math display">\[
\begin{align*}
\frac{|x_{k} - \frac{1}{4}|}{|x_{0} - \frac{1}{4}|} =
10^{-1} \implies \left( \frac{1}{2}\right)
^{k} = 10^{-1}\\
\frac{|x_{k} - \frac{1}{4}|}{|x_{0} - \frac{1}{4}|} =
10^{-1} \implies
2^{-k} = 10^{-1}\\
\frac{|x_{k} - \frac{1}{4}|}{|x_{0} - \frac{1}{4}|} =
10^{-1} \implies
-k \log_{10} 2 = -1\\
\frac{|x_{k} - \frac{1}{4}|}{|x_{0} - \frac{1}{4}|} =
10^{-1} \implies
k = \left\lceil \log_{2} 10 \right\rceil \\
\end{align*}
\]</span></p></li>
</ol></li>
<li><p>NADA</p></li>
<li><p>Derive um método semelhante ao método de Newton para encontrar
raízes de <span class="math inline">\(f(x) = 0\)</span>, utilizando a função <span class="math inline">\(f\)</span>, bem como sua primeira
e segunda derivadas <span class="math inline">\(f^{\prime }, f^{\prime \prime }\)</span>.</p></li>
<li><p>Considere o método de <em>Steffensen</em>: <span class="math display">\[
x_{k+1} = x_{k} - \frac{f(x_{k})}{g(x_{k})}
\]</span> Onde <span class="math display">\[
g(x) = \frac{f(x + f(x)) - f(x)}{f(x)}
\]</span></p>
<ol type="1">
<li><p>Mostre que em geral, o método converge quadraticamente para uma
raiz de <span class="math inline">\(f(x)\)</span>.</p>
<p><span class="math display">\[
h(x) = x - \frac{f(x)^{2}}{f(x + f(x)) - f(x)}
\]</span> <span class="math display">\[
g(x) = x - \frac{f(x)}{f^{\prime }(x)}
\]</span> <span class="math display">\[
\frac{|x_{k} - x^{*}|}{|x_{k+1} - x^{*}|} =
\frac{|x_{k} - x^{*}|}
{\left| x_{k} - \frac{f(x_{k})}{f^{\prime }(x_{k})} - x^{*} \right| }
\]</span> <span class="math display">\[
g^{\prime }(x) = \frac{f^{\prime \prime }(x)f(x)}{f^{\prime }(x)^{2}}g(x) = x - f(x)
\]</span> <span class="math display">\[
g^{\prime }(x^{*}) = 1 - \frac{f^{\prime }(x^{*})^{2} - f^{\prime \prime }(x^{*})f(x^{*})}{f^{\prime }(x^{*})^{2}}
\]</span> <span class="math display">\[
g^{\prime }(x^{*}) = 1 - \frac{f^{\prime }(x^{*})^{2}}{f^{\prime }(x^{*})^{2}} = 0
\]</span> <span class="math display">\[
h(x_{n}) = \frac{f(x_{n}) - f(x_{n-1})}{x_{n} - x_{n-1}}
\]</span> <span class="math display">\[
x_{n+1} = g(x_n) = x_{n} - \frac{(x_{n} - x_{n-1})f(x_{n})}{f(x_{n}) - f(x_{n-1})}
\]</span> <span class="math display">\[
x_{n+2} = h(x_{n}) = g(x_{n}) - \frac{(g(x_{n}) - x_{n})f(g(x_{n}))}{f(g(x_{n})) - f(x_{n})}
\]</span></p></li>
</ol></li>
<li><p>Interpolação polinomial</p>
<ol type="1">
<li><p>asd</p>
<p><span class="math display">\[
\ln u(x) = \ln (\gamma *{0}e^{\gamma*{1}x+\gamma *{2}x^{2}}) =
\ln \gamma*{0} + \gamma_{1}x+\gamma *{2}x^{2}
\]</span> <span class="math display">\[
\begin{align*}
\ln \gamma *{0} + \gamma*{1}x*{0}+\gamma*{2}x*{0}^{2} = z*{0}\\
\ln \gamma *{0} + \gamma*{1}x*{1}+\gamma*{2}x*{1}^{2} = z*{1}\\
\ln \gamma *{0} + \gamma*{1}x*{2}+\gamma*{2}x*{2}^{2} = z*{2}\\  
\end{align*}
\]</span> <span class="math display">\[
\begin{bmatrix}
     \ln \gamma_0 &amp; \gamma_1 &amp; \gamma_2\\
     \ln \gamma_0 &amp; \gamma_1 &amp; \gamma_2\\
     \ln \gamma_0 &amp; \gamma_1 &amp; \gamma_2
\end{bmatrix}
\begin{bmatrix}
     1 \\ x \\ x^2
\end{bmatrix}=
\begin{bmatrix}
     z*{0} \\ z*{1} \\ z*{2}
\end{bmatrix}
\]</span></p></li>
<li><p>Use os valores da função <span class="math inline">\(\sin(x)\)</span> em
<span class="math inline">\(x = 0, \pi /6, \pi /4, \pi /3, \pi /2\)</span> para derivar um
polinômio interpolante <span class="math inline">\(p(x)\)</span>. Qual é o grau desse polinômio?</p>
<p>Como temos <span class="math inline">\(5\)</span> pontos, temos que o grau desse polinômio será
<span class="math inline">\(5-1 = 4\)</span>. Os pontos que devem ser interpolados são:
<span class="math inline">\((0, 0), (\pi /6, 1/2), (\pi /4, \sqrt[]{2}/2), (\pi /3, \sqrt[]{3}/2), (\pi /2, 1)\)</span>.
Nosso polinômio será da forma:
<span class="math inline">\(c*{0} + c*{1}x + c*{2}x² + c*{3}x³+c_{4}x⁴\)</span>. Assim, temos que:
<span class="math display">\[
p(0) = c_{0} = 0
\]</span> <span class="math display">\[
\sin(x_{i} + a) = \sin (x_{i})
+ \cos(x_{i})(a) -
\frac{\sin (\xi *{i})}{2}(a)^{2}
\]</span> <span class="math display">\[
|p(1.2) - \sin (1.2)| =
\left|
     p(1.2) - \sin (\pi /3)
+ \cos(\pi /3)a +
\frac{\sin (\pi /3)}{2}a^{2} +
\frac{\cos (\pi /3)}{6}a^{3} -
\frac{\sin (\xi*{i})}{24}a^{4}
\right|
\]</span> Onde <span class="math inline">\(a = 1.2 - \pi /3\)</span> Mas também temos que: <span class="math display">\[
p(1.2) = p(\pi /3) + p^{\prime }(\pi /3)a + \frac{p^{\prime \prime }(\pi /3)}{2}a^{2} + \frac{p^{\prime \prime \prime }(\pi /3)}{6}a^{3} +
\]</span></p></li>
</ol></li>
</ol>
<h4 data-number="2.7.4.2" id="método-da-secante"><span class="header-section-number">2.7.4.2</span> Método da secante</h4>
<h5 data-number="2.7.4.2.1" id="exercícios-3"><span class="header-section-number">2.7.4.2.1</span> Exercícios</h5>
</body>
</html>
